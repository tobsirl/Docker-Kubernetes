# Dockerfile

| Intructions | Arguments              | Explaination                                                                  |
|-------------|------------------------|-------------------------------------------------------------------------------|
| `FROM`      | alpine                 | Specify the Docker image to be used as a base                                 |
| `RUN`       | apk add --update redis | Executes any instructions in a new layer on top of the image                  |
| `CMD`       | [ "redis-server"]      | Provide defaults for an executing container                                   |
| `COPY`      | ./                     | Copies new files/dir from source and adds them to filesystem of the container |
| `WORKDIR`   | /usr/app               | Sets the working directory                                                    |

Three of the most important instructions to know

### Tagging an image

`docker build -t tobsirl/redis:latest .`

tagging convention
Docker ID - Repo/Project name - Version

running the docker image
`docker run tobsirl/redis`

### Port mapping at run time

`docker run -p 8080:8080 tobsirl/simpleweb`

### Starting a shell in the container

`docker run -it tobsirl/simpleweb sh`
`docker exec -it e5936a165fbc sh`

## Docker Compose

yaml file

```yaml
version: '3'
services: 
  redis-server:
    image: 'redis'
  node-app:
    build: . 
    ports: 
      - "4001:8081"
```

| Command                     | Explaination                                                              |
|-----------------------------|---------------------------------------------------------------------------|
| `docker-compose up`         | Start Containers                                                          |
| `docker-compose up --build` | Start Containers with build                                               |
| `docker-compose up -d`      | Launch in background                                                      |
| `docker-compose down`       | Stop Containers                                                           |
| `docker-compose ps`         | Prints out a list of the running containers (requires docker-compose.yml) |

### Automatic Restarts

| Restart Policies | Explaination                                                        |
|------------------|---------------------------------------------------------------------|
| "no"             | Never attempt to restart this container if it stops or crashes      |
| always           | If this container stops for any reason always attempt to restart it |
| on-failure       | Only restart if the container stops with an error code              |
| unless-stopped   | Always restart unless we (the developers) forcibly stop it          |

## Docker Volumes

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.

`docker build -f Dockerfile.dev .`
`docker run -p 3000:3000 -v /app/node_modules -v$(pwd):/app <imageId>`

## Multi-Step Docker Builds

![Screenshot from 2020-02-11 16-08-02](https://user-images.githubusercontent.com/25591390/74254850-f4b75280-4ce8-11ea-9984-47718ab9c3bc.png)

## Docker Extension

[Docker Containers QuickStart Nodejs](https://code.visualstudio.com/docs/containers/quickstart-node)

## Multi-Container Application

![Screenshot from 2020-02-18 14-34-02](https://user-images.githubusercontent.com/25591390/74745460-d955c580-525b-11ea-932c-5e19b23ed909.png)

### Example of a json file for multi-container deployment with Elastic Beanstalk

```json
{
  "AWSEBDockerrunVersion": 2,
  "containerDefinitions": [
    {
      "name": "client",
      "image": "tobsirl/multi-client",
      "hostname": "client",
      "essential": false
    },
    {
      "name": "server",
      "image": "tobsirl/multi-server",
      "hostname": "api",
      "essential": false
    },
    {
      "name": "worker",
      "image": "tobsirl/multi-worker",
      "hostname": "worker",
      "essential": false
    },
    {
      "name": "nginx",
      "image": "tobsirl/multi-nginx",
      "hostname": "nginx",
      "essential": true,
      "portMappings": [
        {
          "hostPort": 80,
          "containerPort": 80
        }
      ],
      "links": ["client", "server"]
    }
  ]
}
```

## Docker Commands

```bash
docker run node # download latest node image and run it

docker ps -a # list all containers

docker run -it node # run container in interactive mode

docker srart <containerId> # start previous container
docker stop <containerId> # stop container

# Attached and Detached mode
docker run -it node # attached mode
docker run -it -d node # detached mode
docker start -a -i <containerId> # attached mode

# Attach to a running container
docker attach <containerId>

# dokcer logs
docker logs <containerId>
docker logs -f <containerId> # follow logs
docker logs -f -t <containerId> # follow logs with timestamps
dokker logs --tail 5 <containerId> # show last 5 logs

# docker interactive mode
docker run -it <containerId> sh # run shell in container
-i, --interactive                    Keep STDIN open even if not attached
-t, --tty                            Allocate a pseudo-TTY

docker start -i -a <containerId> # start container in interactive mode

# docker deleting images and containers
docker rm <containerId> # remove container
docker rm <containerId> <containerId> <containerId> # remove multiple containers
docker rmi <imageId> # remove image
docker rmi <imageId> <imageId> <imageId> # remove multiple images

# docker run remove container after exit
docker run --rm -it <containerId> sh

# inspect an image
docker image inspect <imageId>

# docker copy files into a container
docker cp <file> <containerId>:<path>

# docker copy files from a container
docker cp <containerId>:<path> <file>

# docker naming containers
docker run --name <name> <containerId>

# docker naming images
docker build -t <repo>:<tag> .
```

## Two Types of External Data Storages

Volumes(Managed by Docker) and Bind Mounts(Managed by you)

## Docker Volumes

Anonymouse Volumes and Named Volumes
Docker sets up a folder / path on you host machine, exact location is unknown to you, managed via docker volume commands

A defined path in the container is mapped to the created volume / mount. e.g. /some-path on your hosting machine is mapped to /app/data

Great for data which should be persisted, but which you don't need to edit directly.

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.

Volumes are folders on your host machine hard drive which are mounted ("made available", mapped) into containers.

```bash
# named volumes
docker run -v <volumeName>:<path> <containerId>

# removing anonymous volumes
docker volume rm <volumeName>
docker volume prune # remove all unused volumes
```

## Bind Mounts

Bind Mounts are specified by you, the developer, at container launch time.

With bind mounts, you specify a specific folder on the host machine. This folder is then mounted into the container.

Bind mounts are great for when you want to actively develop code on your host machine (e.g. using your code editor) and test it inside a container.

You define a folder / path on your host machine. This folder is then mounted into the container.

Great for persistent, editable data e.g. source code.

### Volume commands
  
```bash
# list volumes
docker volume ls

# inspect volume
docker volume inspect <volumeName>

# remove volume
docker volume rm <volumeName>
```

## Arguments and Environment Variables

Docker supports build-time arguments and runtime environment variables.

### Build Time Arguments

Available inside of Dockerfile, **NOT** accesssible in CMD or application code.

Set on image build (docker build) `--build-arg <argName>=<argValue>`

### Environment Variables

Available inside of Dockerfile and in the application code.

Set via ENV in Dockerfile or via --env on `docker run`

```bash
docker run -e <envName>=<envValue> <containerId> # set environment variable

docker run --env-file <path> <containerId> # set multiple environment variables

docker run --env-file ./.env <containerId> # set multiple environment variables from .env file

```

### Environment Variables & Security

One important note about environment variables and security: Depending on which kind of data you're storing in your environment variables, you might not want to include the secure data directly in your `Dockerfile`.

Instead, go for a separate environment variables file which is then only used at runtime (i.e. when you run your container with `docker run`).

Otherwise, the values are "baked into the image" and everyone can read these values via `docker history <image>`.

For some values, this might not matter but for credentials, private keys etc. you definitely want to avoid that!

If you use a separate file, the values are not part of the image since you point at that file when you run `docker run`. But make sure you don't commit that separate file as part of your source control repository, if you're using source control.

## Networks

### Container to Web Communication

Works out of the box

### Container to Host Communication

use `host.docker.internal` as the host address

### Container to Container Communication

Create a network and add containers to it

```bash
# create a network
docker network create <networkName>

# list networks
docker network ls
```

## Docker Compose

### What is Docker Compose?

Docker Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application's services. Then, with a single command, you create and start all the services from your configuration.
